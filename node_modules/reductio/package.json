{
  "name": "reductio",
  "version": "0.6.3",
  "description": "Reductio: Crossfilter groupings",
  "main": "src/reductio.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "crossfilter2": "^1.4.0-alpha.6"
  },
  "devDependencies": {
    "browserify": "^8.1.1",
    "browserify-shim": "^3.7.0",
    "gulp": "^3.7.0",
    "gulp-bump": "^0.1.13",
    "gulp-concat": "^2.2.0",
    "gulp-karma": "0.0.4",
    "gulp-rename": "^1.2.0",
    "gulp-streamify": "0.0.5",
    "gulp-uglify": "^1.0.2",
    "karma": "^0.12.16",
    "karma-chrome-launcher": "^0.1.4",
    "karma-firefox-launcher": "^0.1.4",
    "karma-jasmine": "~0.1.0",
    "karma-phantomjs-launcher": "^0.1.4",
    "lodash": "^3.3.0",
    "vinyl-source-stream": "^1.0.0"
  },
  "scripts": {
    "test": "./node_modules/karma/bin/karma start --browsers PhantomJS --single-run"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/esjewett/reductio.git"
  },
  "keywords": [
    "crossfilter"
  ],
  "author": {
    "name": "Ethan Jewett"
  },
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/esjewett/reductio/issues"
  },
  "homepage": "https://github.com/esjewett/reductio",
  "browser": {
    "crossfilter": "crossfilter2"
  },
  "browserify-shim": {
    "crossfilter2": "global:crossfilter"
  },
  "readme": "Reductio: Crossfilter grouping\n========\n\n[![Join the chat at https://gitter.im/crossfilter/reductio](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/crossfilter/reductio?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nReductio is a library for generating Crossfilter reduce functions and applying them to Crossfilter groups. Crossfilter supports basic count and sum aggregations, but even aggregations as conceptually simple as a group minimum or maximum can be difficult to build correctly and efficiently on a Crossfilter group. Reductio provides helper functions that generate these aggregations in an efficient and composable way, making it easy to use more complex aggregations with Crossfilter and to have more than one aggregation per group without having to worry about designing 2-way reduce functions.\n\n[![NPM version](http://img.shields.io/npm/v/reductio.svg?style=flat)](https://www.npmjs.org/package/reductio)\n[![Bower version](http://img.shields.io/bower/v/reductio.svg?style=flat)](http://bower.io/search/?q=reductio)\n[![Travis build status](http://img.shields.io/travis/crossfilter/reductio/master.svg?style=flat)](https://travis-ci.org/esjewett/reductio)\n[![Dependency Status](https://david-dm.org/crossfilter/reductio.svg?style=flat)](https://david-dm.org/crossfilter/reductio)\n\n<h1 id=\"example\">Example</h1>\n\nBasic use:\n\n```javascript\nvar data = crossfilter([\n  { foo: 'one', bar: 1 },\n  { foo: 'two', bar: 2 },\n  { foo: 'three', bar: 3 },\n  { foo: 'one', bar: 4 },\n  { foo: 'one', bar: 5 },\n  { foo: 'two', bar: 6 },\n]);\n\nvar dim = data.dimension(function(d) { return d.foo; });\nvar group = dim.group();\n\n// Equivalent to reductio().avg(function(d) { return d.bar; }), which sets the .sum() and .count() values.\nvar reducer = reductio()\n    .count(true)\n    .sum(function(d) { return d.bar; })\n    .avg(true);\n\n// Now it should track count, sum, and avg.\nreducer(group);\n\ngroup.top(Infinity);\n// [ { key: 'one', value: { count: 3, sum: 10, avg: 3.3333333 },\n//   { key: 'two', value: { count: 2, sum: 8, avg: 4 },\n//   { key: 'three', value: { count: 1, sum: 3, avg: 3 } ]\n```\n\n<h1 id=\"toc\">Table of Contents</h1>\n\n* [Example](#example)\n* [Table of Contents](#toc)\n* [Installation](#installation)\n    * [NPM](#installation-npm)\n    * [Bower](#installation-bower)\n    * [Download](#installation-download)\n    * [CDN](#installation-cdn)\n* [Getting Help](#getting-help)\n* [Accessor Functions](#accessor-functions)\n* [Aggregations](#aggregations)\n    * [Standard aggregations](#aggregations-standard-aggregations)\n        * [reductio.<b>count</b>()](#aggregations-standard-aggregations-reductio-b-count-b-)\n        * [reductio.<b>sum</b>(<i>value</i>)](#aggregations-standard-aggregations-reductio-b-sum-b-i-value-i-)\n        * [reductio.<b>avg</b>(<i>boolean</i>|<i>value</i>)](#aggregations-standard-aggregations-reductio-b-avg-b-i-boolean-i-i-value-i-)\n        * [reductio.<b>min</b>(<i>boolean</i>|<i>value</i>)](#aggregations-standard-aggregations-reductio-b-min-b-i-boolean-i-i-value-i-)\n        * [reductio.<b>max</b>(<i>boolean</i>|<i>value</i>)](#aggregations-standard-aggregations-reductio-b-max-b-i-boolean-i-i-value-i-)\n        * [reductio.<b>median</b>(<i>boolean</i>|<i>value</i>)](#aggregations-standard-aggregations-reductio-b-median-b-i-boolean-i-i-value-i-)\n        * [reductio.<b>sumOfSq</b>(<i>value</i>)](#aggregations-standard-aggregations-reductio-b-sumofsq-b-i-value-i-)\n        * [reductio.<b>std</b>(<i>boolean</i>|<i>value</i>)](#aggregations-standard-aggregations-reductio-b-std-b-i-boolean-i-i-value-i-)\n        * [Histogram](#aggregations-standard-aggregations-histogram)\n            * [reductio.<b>histogramBins</b>(<i>thresholdArray</i>)](#aggregations-standard-aggregations-histogram-reductio-b-histogrambins-b-i-thresholdarray-i-)\n            * [reductio.<b>histogramValue</b>(<i>value</i>)](#aggregations-standard-aggregations-histogram-reductio-b-histogramvalue-b-i-value-i-)\n        * [reductio.<b>value</b>(<i>propertyName</i>)](#aggregations-standard-aggregations-reductio-b-value-b-i-propertyname-i-)\n        * [reductio.<b>filter</b>(<i>filterFn</i>)](#aggregations-standard-aggregations-reductio-b-filter-b-i-filterfn-i-)\n        * [reductio.<b>nest</b>(<i>keyAccessorArray</i>)](#aggregations-standard-aggregations-reductio-b-nest-b-i-keyaccessorarray-i-)\n        * [reductio.<b>alias</b>(<i>mapping</i>)](#aggregations-standard-aggregations-reductio-b-alias-b-i-mapping-i-)\n        * [reductio.<b>aliasProp</b>(<i>mapping</i>)](#aggregations-standard-aggregations-reductio-b-aliasprop-b-i-mapping-i-)\n        * [reductio.<b>valueList</b>(<i>accessor</i>)](#aggregations-standard-aggregations-reductio-value-list)\n        * [reductio.<b>dataList</b>(<i>boolean</i>)](#aggregations-standard-aggregations-reductio-data-list)\n        * [reductio.<b>custom</b>(<i>initial,add,remove</i>)](#aggregations-standard-aggregations-reductio-custom)\n        * [Exception aggregation](#aggregations-standard-aggregations-exception-aggregation)\n            * [reductio.<b>exception</b>(<i>accessor</i>)](#aggregations-standard-aggregations-exception-aggregation-reductio-b-exception-b-i-accessor-i-)\n            * [reductio.<b>exceptionCount</b>(<i>boolean</i>)](#aggregations-standard-aggregations-exception-aggregation-reductio-b-exceptioncount-b-i-boolean-i-)\n            * [reductio.<b>exceptionSum</b>(<i>value</i>)](#aggregations-standard-aggregations-exception-aggregation-reductio-b-exceptionsum-b-i-value-i-)\n    * [groupAll aggregations](#aggregations-groupall-aggregations)\n        * [reductio.<b>groupAll</b>(<i>groupingFunction</i>)](#aggregations-groupall-aggregations-reductio-b-groupall-b-i-groupingfunction-i-)\n    * [Chaining aggregations](#aggregations-chaining-aggregations)\n* [Post-processing](#postprocess)\n    * [group.post().<b>cap</b>(<i>length</i>)](#cap)\n* [Utilities](#utilities)\n    * [reductio().<b>fromObject</b>(<i>parameters</i>)](#utilities-fromObject)\n    * [reductio().<b>toObject</b>()](#utilities-toObject)\n\n\n<h1 id=\"installation\">Installation</h1>\n\n<h2 id=\"installation-npm\">NPM</h2>\n```shell\nnpm install --save-dev reductio\n```\n\n<h2 id=\"installation-bower\">Bower</h2>\n```shell\nbower install --save-dev reductio\n```\n\n<h2 id=\"installation-download\">Download</h2>\nDownload from the [releases](https://github.com/esjewett/reductio/releases) page. Serve the reductio.js or reductio.min.js file in the top-level directory as part of your application.\n\n<h2 id=\"installation-cdn\">CDN</h2>\nReductio is available via cdnjs. You can generate links to different versions of Reductio at: https://cdnjs.com/libraries/reductio\n\n<h1 id=\"getting-help\">Getting help</h1>\n\nIf something doesn't appear to be working or you're having trouble with implementing something, it will usually be best to ask a question on Stackoverflow and tag the question with the [reductio tag](http://stackoverflow.com/questions/tagged/reductio). When you ask your question, it is best to put together a working example showing the problem you are having. A [JSFiddle template](https://jsfiddle.net/esjewett/jusjkm8j/) is available that already includes the Reductio and Crossfilter libraries, as well as dc.js. Use that template to make an example showing what you are seeing. In your question, reference the example, explain what you are seeing, and explain what you expect or want to see instead.\n\nThere is also a [Reductio Gitter](https://gitter.im/crossfilter/reductio), which is a good place to check in for help if you have a quick question that doesn't fit into the Stackoverflow format, or if you are looking for a more conceptual discussion.\n\n<h1 id=\"accessor-functions\">Accessor functions</h1>\n\nIn most cases when an accessor function is required, Reductio supports the use of the property name to be accessed in the form or a string instead. When appropriate, Reductio will even cast the value of a property to a number for you, though be aware that this will convert nulls and undefined values into 0s.\n\nFor example, the following:\n\n```javascript\nreducer = reductio().sum(function(d) { return +d.number; });\nreducer(group);\n```\n\nIs equivalent to:\n\n```javascript\nreducer = reductio().sum('number');\nreducer(group);\n```\n\nAggregations that support this syntax with casting to a numeric value: sum, avg, exception sum, histogram value, min, max, median\n\nAggregations that support this syntax without casting: nest, exception, value list, standard deviation, sum of squares\n\n<h1 id=\"aggregations\">Aggregations</h1>\n\nAggregations are composable (so you can track more than one aggregation on a given group) and may depend on each other (the 'avg' aggregation requires that 'count' and 'sum' be specified).\n\n<h2 id=\"aggregations-standard-aggregations\">Standard aggregations</h2>\nCurrent aggregations supported are shown given the following setup.\n\n```javascript\nvar data = crossfilter([...]);\nvar dim = data.dimension(...);\nvar group = dim.group();\nvar reducer;\n```\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-count-b-\">reductio.<b>count</b>()</h3>\nWorks the same way as Crossfilter's standard ```group.reduceCount()```.\n\n```javascript\nreducer = reductio().count(true);\nreducer(group);\n```\n\nStored under the 'count' property of groups. The value will be a count of every record that matches the group accessor.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-sum-b-i-value-i-\">reductio.<b>sum</b>(<i>value</i>)</h3>\nWorks the same was as Crossfilter's standard ```group.reduceSum()```.\n\n```javascript\nreducer = reductio().sum(function(d) { return +d.number; });\nreducer(group);\n```\n\nStored under the 'sum' property of groups. The value is a sum of ```accessor(d)``` for every record ```d``` that matches the group accessor. The accessor function must return a number.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-avg-b-i-boolean-i-i-value-i-\">reductio.<b>avg</b>(<i>boolean</i>|<i>value</i>)</h3>\n```javascript\nreductio().avg(function(d) { return +d.number; })(group);\n```\nStored under the 'avg' property of groups. Boolean variation depends on *count* and *sum* aggregations being specified. If an accessor function is provided, that function will be used to create a sum aggregation on the group, and a count aggregation will be created as well. The value on the 'avg' property is equal to sum/count for the group.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-min-b-i-boolean-i-i-value-i-\">reductio.<b>min</b>(<i>boolean</i>|<i>value</i>)</h3>\n<h3 id=\"aggregations-standard-aggregations-reductio-b-max-b-i-boolean-i-i-value-i-\">reductio.<b>max</b>(<i>boolean</i>|<i>value</i>)</h3>\n<h3 id=\"aggregations-standard-aggregations-reductio-b-median-b-i-boolean-i-i-value-i-\">reductio.<b>median</b>(<i>boolean</i>|<i>value</i>)</h3>\n```javascript\nreductio().min(function(d) { return +d.number; })\n  .max(true)\n  .median(true)(group);\n```\nStored under the 'median', 'min', and 'max' property of groups.\n\nOnce you've defined one accessor function for min, max, or median (or if you have explicitly defined a ```redectio.valueList(value)```) it will be used by the others. This avoids warning messages about overwriting the valueList.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-sumofsq-b-i-value-i-\">reductio.<b>sumOfSq</b>(<i>value</i>)</h3>\n```javascript\nreductio().sumOfSq(function(d) { return d.number; })(group);\n```\nStored under the 'sumOfSq' property of the group. Defined as the square of the value returned by the accessor function summed over all records in the group. This is used in the standard deviation aggregation, but can be used on its own as well.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-std-b-i-boolean-i-i-value-i-\">reductio.<b>std</b>(<i>boolean</i>|<i>value</i>)</h3>\n```javascript\nreductio().sumOfSq(function(d) { return d.number; })\n    .sum(function(d) { return d.number; })\n    .count(true)\n    .std(true)(group);\nreductio()\n    .std(function(d) { return d.number; })(group);\n```\nStored under the 'std' property of the group. Defined as the sum-of-squares minus the average of the square of sums for all records in the group. In other words, for group 'g', ```g.sumOfSq - g.sum*g.sum/g.count```.\n\nIf ```sumOfSq```, ```sum```, and ```count``` are already defined, takes a boolean. Otherwise pass in an accessor function directly.\n\n<h3 id=\"aggregations-standard-aggregations-histogram\">Histogram</h3>\n```javascript\nreductio().histogramBins([0,2,6,10])\n        .histogramValue(function(d) { return +d.number; })(group)\n```\n\nHistogram of values within grouping, stored on the 'histogram' property of the group. Acts like [d3.layout.histogram](https://github.com/mbostock/d3/wiki/Histogram-Layout) defined using bins(thresholds).\n\nThis grouping should be usable anywhere d3.layout.histogram can be used. May be useful for small-multiples charts, or for use with the dc.js stack mixin.\n\nThe property ```group.histogram``` is an array. Each element of the array is a sorted array of values returned by ```histogramValue``` that fall into that bin. Each element of the array also has properties, x, dx, and y, as defined in the d3.layout.histogram documentation.\n\n<h4 id=\"aggregations-standard-aggregations-histogram-reductio-b-histogrambins-b-i-thresholdarray-i-\">reductio.<b>histogramBins</b>(<i>thresholdArray</i>)</h4>\nDefines the bin thresholds for the histogram. Will result in ```thresholdArray.length - 1``` bins.\n\n<h4 id=\"aggregations-standard-aggregations-histogram-reductio-b-histogramvalue-b-i-value-i-\">reductio.<b>histogramValue</b>(<i>value</i>)</h4>\nAccessor for the value to be binned.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-value-b-i-propertyname-i-\">reductio.<b>value</b>(<i>propertyName</i>)</h3>\n```javascript\nvar reducer = reductio();\nreducer.value(\"x\").sum(xSumAccessor);\nreducer.value(\"y\").count(true).sum(ySumAccessor).avg(true);\nreducer(group);\n```\n\nAllows group structures such as\n\n```javascript\n{\n  x: { sum: 5 }\n  y: { count: 3, sum: 12, avg: 4 }\n}\n```\n\nUsed for tracking multiple aggregations on a single group. For example, sum of x and sum of y. Useful for visualizations like scatter-plots where individual marks represent multiple dimensions in the data. ```propertyName``` must be a valid Javascript object property name and must not conflict with any of the property names already used by Reductio (i.e. ```count```, ```sum```, ```avg```, etc.).\n\nAs many values as desired can be defined and any aggregation in this list can be defined on a value and they are calculated independently from aggregations defined on other values or on the base level of the group. Therefore, values are the way to deal with scenarios in which you want to calculated the same aggregation twice with difference logic (sum credits *and* sum debits) or where you are struggling with aggregations that are interdependent (average and sum are linked, so if you want to average a different value than you are summing, use a value).\n\nNote that exception aggregations are supported on values, but groupAll aggregations are not.\n\nA more comprehensive example:\n\n```javascript\nvar reducer = reductio();\nreducer.value(\"w\").exception(function(d) { return d.bar; }).exceptionSum(function(d) { return d.num1; });\nreducer.value(\"x\").exception(function(d) { return d.bar; }).exceptionSum(function(d) { return d.num2; });\nreducer.value(\"y\").sum(function(d) { return d.num3; });\nreducer.value(\"z\").sum(function(d) { return d.num4; });\nreducer(group);\n```\n\nWill result in groups that look like\n\n```javascript\n{ key: groupKey, value: {\n  w: { exceptionSum: 2 },\n  x: { exceptionSum: 3 },\n  y: { sum: 4 },\n  z: { sum: 2 }\n}}\n```\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-filter-b-i-filterfn-i-\">reductio.<b>filter</b>(<i>filterFn</i>)</h3>\n```javascript\nreductio().filter(filterFn)(group)\n```\nFilters values from being added/removed from groups.  Works well with ```value```\nchains, and is also very useful if you need to aggregate sparsely-populated fields.\n\n```javascript\nvar reducer = reductio();\nreducer.value(\"evens\").count(true)\n  .filter(function(d) { return d.bar % 2 === 0}; });\nreducer.value(\"rare\")\n  .filter(function(d) { return typeof d.rareVal === 'undefined' ; })\n  .sum(function(d) return d.rareVal; );\nreducer(group);\n```\n\nFor example:\n\n```javascript\n// Given:\n[\n  { foo: 'one', num: 1 },\n  { foo: 'two', num: 2 },\n  { foo: 'three', num: 3, rareVal: 98 },\n  { foo: 'one', num: 3, rareVal: 99 },\n  { foo: 'one', num: 4, rareVal: 100 },\n  { foo: 'two', num: 6 }\n]\n\n// The groups will look like:\n[\n  { key: 'one', value: { evens: { count: 1 }, rare: { sum: 199 } }\n  { key: 'two', value: { evens: { count: 2 }, rare: { sum: 98 } }\n  { key: 'three', value: { evens: { count: 0 }, rare: { sum: 0 } }\n]\n```\n\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-nest-b-i-keyaccessorarray-i-\">reductio.<b>nest</b>(<i>keyAccessorArray</i>)</h3>\n```javascript\nreductio().nest([keyAccessor1, keyAccessor2])(group)\n```\n\nStored under the 'nest' property of the group.\n\nProvides a result similar to ```d3.nest().key(keyAccessor1).key(keyAccessor2)``` when applied to the records in the group.\n\nUsually you'll want to use the group key as the first level of nesting, then use this to accomplish sub-group nesting.\n\nNote that leaves will not be created when there is no record with that value in the branch. However, once a leaf is created it is not removed, so there is the possibility of leaves with empty 'values' arrays.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-alias-b-i-mapping-i-\">reductio.<b>alias</b>(<i>mapping</i>)</h3>\n```javascript\nreductio().count(true).alias({ newCount: function(g) { return g.count; } });\n```\n\nAllows definition of an accessor function of any name on the group that returns a value from the group. ```mapping`` is an object where keys are the new properties that will be added to the group and values are the accessor functions that get the required values from the group.\n\nOn the group, we can then call the following function to retrieve the new count value.\n```javascript\ngroup.top(1)[0].newCount();\n```\n\nThis approach to aliases is more efficient than the aliasProp approach below because it executes no logic at the time off aggregation.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-b-aliasprop-b-i-mapping-i-\">reductio.<b>aliasProp</b>(<i>mapping</i>)</h3>\n```javascript\nreductio().count(true)\n  .sum(function(d) { return +d.num; })\n  .aliasProp({\n      newCount: function(g) { return g.count; },\n      average: function(g) { return g.sum / g.count; },\n      description: function (g, v) { return v.desc; }\n  });\n```\n\nAllows definition of an accessor function of any name on the group that returns a value from the group. ```mapping`` is an object where keys are the new properties that will be added to the group and values are the values returned by the accessor function.\n\nAccessors also have access to the record, so you can use this function to do things like assigning additional descriptive information to the group property based on the records seen.\n\nOn the group, we can then call the following to retrieve the count value.\n```javascript\ngroup.top(1)[0].newCount;\ngroup.top(1)[0].average;\ngroup.top(1)[0].description;\n```\n\nIt is *very* important that the functions in the _mapping_ don't modify the group directly. The functions are run after all aggregations are calculated and the same function is run for adding and removing records. Because the accessor functions are run on the group every time a record is added or removed, this is less efficient than the function-based approach in reductio.alias above.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-value-list\">reductio.<b>valueList</b>(<i>accessor</i>)</h3>\n```javascript\nvar reducer = reductio()\n   .sum(function (d) { return d.bar; })\n   .valueList(function (d) { return d.bar; });\n```\n\nMaintains a `valueList` property on the group containing an array of values returned by `accessor` for every record added to the group. This property is used internally by other aggregations like `min`, `max`, and `median`, so watch for warning messages on the console.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-data-list\">reductio.<b>dataList</b>(<i>boolean</i>)</h3>\n```javascript\nvar reducer = reductio()\n   .sum(function (d) { return d.bar; })\n   .dataList(true);\n```\n\nMaintains a `dataList` property on the group containing an array of records included in the group. This is similar to `valueList` used with the identity function as the accessor, but is slightly more efficient.\n\n<h3 id=\"aggregations-standard-aggregations-reductio-custom\">reductio.<b>custom</b>(<i>initial,add,remove</i>)</h3>\n```javascript\nvar reducer = reductio()\n  .custom({\n    add: function(p, v) {\n      p.myProp += v.foo.length;\n      return p;\n    },\n    remove: function(p, v) {\n      p.myProp -= v.foo.length;\n      return p;\n    },\n    initial: function(p) {\n      p.myProp = 0;\n      return p;\n    }\n  });\n```\n\nApplies specified custom reducer to every record of every group.\nThis property allows to plug any custom extension in Reductio's API.\n\n<h3 id=\"aggregations-standard-aggregations-exception-aggregation\">Exception aggregation</h3>\nWe also support exception aggregation. For our purposes, this means only aggregating once for each unique value that the exception accessor returns. So:\n\n```javascript\nvar data = crossfilter([\n  { foo: 'one', bar: 'A', num: 1 },\n  { foo: 'two', bar: 'B', num: 2 },\n  { foo: 'three', bar: 'A', num: 3 },\n  { foo: 'one', bar: 'B', num: 2 },\n  { foo: 'one', bar: 'A', num: 1 },\n  { foo: 'two', bar: 'B', num: 2 },\n]);\n\nvar dim = data.dimension(function(d) { return d.foo; });\nvar group = dim.group();\n\nvar reducer = reductio()\n    .exception(function(d) { return d.bar; })\n    .exceptionCount(true)\n    .exceptionSum(function(d) { return d.num; });\n\nreducer(group);\n\ngroup.top(Infinity);\n// [ { key: 'one', value: { exceptionCount: 2, exceptionSum: 3 },    // 'bar' dimension has 2 values: 'A' and 'B'.\n//   { key: 'two', value: { exceptionCount: 1, exceptionSum: 2 },    // 'bar' dimension has 1 value: 'B'.\n//   { key: 'three', value: { exceptionCount: 1 , exceptionSum: 3} ] // 'bar' dimension has 1 value: 'A'.\n```\n\nRight now we support exceptionCount and exceptionSum, but it might also make sense to support other types of dependent aggregation. These types of aggregations are meant to help with a situation where you want to use Crossfilter on a flattened one-to-many or many-to-many relational model, which can result in redundant values.\n\n<h4 id=\"aggregations-standard-aggregations-exception-aggregation-reductio-b-exception-b-i-accessor-i-\">reductio.<b>exception</b>(<i>accessor</i>)</h4>\n\nThe exception accessor defines the value by which to restrict the calculation of the exception aggregation. In each group, only the first record with each unique value returned by this accessor will be considered for aggregation.\n\n<h4 id=\"aggregations-standard-aggregations-exception-aggregation-reductio-b-exceptioncount-b-i-boolean-i-\">reductio.<b>exceptionCount</b>(<i>boolean</i>)</h4>\n\nA count subject to exception calculation.\n\n<h4 id=\"aggregations-standard-aggregations-exception-aggregation-reductio-b-exceptionsum-b-i-value-i-\">reductio.<b>exceptionSum</b>(<i>value</i>)</h4>\n\nA sum subject to exception calculation. Make sure that for each value within a group that the exception accessor returns, the exceptionSum accessor returns an identical value, or results will be unpredictable because the record added for each exception value will not necessarily be the same record that is removed.\n\n<h2 id=\"aggregations-groupall-aggregations\">groupAll aggregations</h2>\n\nSometimes it is necessary to include one record in multiple groups. This is common in OLAP scenarios, classification, and tracking moving averages, to give a few examples. Say we have a data set like\n\n```javascript\n[\n  { foo: 'one', num: 1 },\n  { foo: 'two', num: 2 },\n  { foo: 'three', num: 2 },\n  { foo: 'one', num: 3 },\n  { foo: 'one', num: 4 },\n  { foo: 'two', num: 5 },\n]\n```\n\nWe want to track a moving count of the last 2 values on the ```num``` property. So our group with a key ```2``` should count up all records with a ```num``` of ```2``` *or* ```1```. Normally this must be done using the Crossfilter dimension.groupAll method. With reductio we can use all the standard reductio reducers in this type of scenario by specifying some additional groupAll information and called the reducer on the output of ```dimension.groupAll``` *instead* of the output of ```dimension.group```.\n\nThe object returned by ```dimension.groupAll``` in Crossfilter does not have the standard ```all```, ```top```, or ```order``` methods. As a convenience, the reducer function produced by Reductio adds an ```all``` method to this object if it does not already exist.\n\n<h3 id=\"aggregations-groupall-aggregations-reductio-b-groupall-b-i-groupingfunction-i-\">reductio.<b>groupAll</b>(<i>groupingFunction</i>)</h3>\n\nTakes a single argument: a function that takes a record from the data set (e.g. ```{ foo: 'three', num: 2 }```) and returns an array of keys of the groups that the record should be included in (e.g. ```[2,3]```). This is a very simple example, but the same thing could be done for dates, with a function for a 5-day moving average returning an array of 5 dates.\n\n```javascript\ndata.dimension(function(d) { return d.num; });\nfilterDim = data.dimension(function(d) { return d.foo; });\ngroupAll = dim.groupAll();\n\nreducer = reductio()\n  .groupAll(function(record) {\n    if(record.num === 5) {\n      return [5];\n    } else {\n      return [record.num, record.num+1];\n    }\n  })\n  .count(true);\n\nreducer(groupAll);\n```\n\n<h2 id=\"aggregations-chaining-aggregations\">Chaining aggregations</h2>\nAs seen above, aggregations can be chained on a given instance of reductio. For example:\n\n```javascript\nreductio().count(true)\n    .sum(function(d) { return d.bar; })\n    .avg(true)(group);\n```\n\n<h1 id=\"postprocess\">Post-processing</h1>\nReductio adds a `post` function to your group. Calling this function returns an object on which you can make settings to allow you to post-process your data in useful ways.\n\n<h2 id=\"cap\">group.post().<b>cap</b>(<i>length</i>)</h1>\nCap the output of your group so that it never exceeds `length` elements.\n\nThe last element will be an aggregation of the rest of the elements. It might be wise to set your groups `order` method before using this.\n\n```javascript\nreductio()\n    .count(true)\n    .sum('foo')\n    .avg(true)(group);\ngroup.post().cap(4)().length // 4 or less\n```\n\n<h1 id=\"utilities\">Utilities</h1>\n\n<h2 id=\"utilities-fromObject\">reductio().<b>fromObject</b>(<i>parameters</i>)</h2>\n\nA utility that will allow you to assign directly to the inner object from which reductio creates its groupings.\n\nBasic use:\n```js\nreductio()\n  .fromObject({\n    sum: function(d){\n      return d.foo;\n    }\n  })(group);\n```\n\n<h2 id=\"utilities-toObject\">reductio().<b>toObject</b>()</h2>\nReturns the current state of the reductio instance.\n",
  "readmeFilename": "README.md",
  "_id": "reductio@0.6.3",
  "dist": {
    "shasum": "9915cb466c663bed653d72c26c83ce3ff61b3023"
  },
  "_from": "reductio@",
  "_resolved": "https://registry.npmjs.org/reductio/-/reductio-0.6.3.tgz"
}
